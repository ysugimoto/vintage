// Code generated by __generator__/interpreter.go at once

package builtin

import (
	"math/big"
	"net/netip"

	"github.com/ysugimoto/falco/interpreter/context"
	"github.com/ysugimoto/falco/interpreter/function/errors"
	"github.com/ysugimoto/falco/interpreter/value"
)

const Addr_extract_bits_Name = "addr.extract_bits"

var Addr_extract_bits_ArgumentTypes = []value.Type{value.IpType, value.IntegerType, value.IntegerType}

func Addr_extract_bits_Validate(args []value.Value) error {
	if len(args) != 3 {
		return errors.ArgumentNotEnough(Addr_extract_bits_Name, 3, args)
	}
	for i := range args {
		if args[i].Type() != Addr_extract_bits_ArgumentTypes[i] {
			return errors.TypeMismatch(Addr_extract_bits_Name, i+1, Addr_extract_bits_ArgumentTypes[i], args[i].Type())
		}
	}
	return nil
}

// Fastly built-in function implementation of addr.extract_bits
// Arguments may be:
// - IP, INTEGER, INTEGER
// Reference: https://developer.fastly.com/reference/vcl/functions/miscellaneous/addr-extract-bits/
func Addr_extract_bits(ctx *context.Context, args ...value.Value) (value.Value, error) {
	// Argument validations
	if err := Addr_extract_bits_Validate(args); err != nil {
		return value.Null, err
	}

	ip := value.Unwrap[*value.IP](args[0])
	startBit := value.Unwrap[*value.Integer](args[1])
	bitCount := value.Unwrap[*value.Integer](args[2])

	if !startBit.IsLiteral() {
		return value.Null, errors.New(Addr_extract_bits_Name, "start_bit must be a literal")
	}
	if !bitCount.IsLiteral() {
		return value.Null, errors.New(Addr_extract_bits_Name, "bit_count must be a literal")
	}
	if bitCount.Value > 32 {
		return value.Null, errors.New(Addr_extract_bits_Name, "start_bit must be less than 32")
	}
	if bitCount.Value+startBit.Value > 128 {
		return value.Null, errors.New(Addr_extract_bits_Name, "start_bit plus bit_count must be less than 128")
	}

	addr, err := netip.ParseAddr(ip.Value.String())
	if err != nil {
		return value.Null, errors.New(Addr_extract_bits_Name, "Failed to parse IP address %s, %s", ip.Value.String(), err)
	}
	bits := addr.AsSlice()
	if len(bits) == 4 { // If ipv4, pad with zeros on the left
		bits = append([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, bits...)
	}

	// IPv6 (128 bits) integer is too large so need to calculate with bigint
	bi := new(big.Int)
	bi.SetBytes(bits)

	// Right shift of start_bit
	bi.Rsh(bi, uint(startBit.Value))

	// Create mask bit of bit_count and calculate AND
	mask := big.NewInt(0)
	for i := 0; i < int(bitCount.Value); i++ {
		c := big.NewInt(1)
		mask.Or(mask, c.Lsh(c, uint(i)))
	}
	bi.And(bi, mask)

	return &value.Integer{Value: bi.Int64()}, nil
}
